name: AWS Deployment Pipeline

on:
  workflow_run:
    workflows: ["Build and Push"]
    types:
      - completed
    branches:
      - main
  workflow_dispatch:
    inputs:
      image_digest_ec2:
        description: 'Digest for EC2 image (sha256:...)'
        required: true
      image_digest_lambda:
        description: 'Digest for Lambda image (sha256:...)'
        required: true
      environment:
        description: 'Target Environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - prod

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: eu-central-1

jobs:
  deploy-lambda:
    name: Lambda Target Deployment
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Authenticate with AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Determine Artifact Digest
        id: image
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            SELECTED_DIGEST="${{ github.event.inputs.image_digest_lambda }}"
            TARGET_ENV="${{ github.event.inputs.environment }}"
          else
            SELECTED_DIGEST=$(aws ecr describe-images \
              --repository-name podinfo-demo/podinfo \
              --query "sort_by(imageDetails[?imageTags!=null], &imagePushedAt) | reverse(@)[?contains(imageTags[0], 'lambda')] | [0].imageDigest" \
              --output text)
            TARGET_ENV="dev"
          fi
          
          FULL_URI="553600746148.dkr.ecr.eu-central-1.amazonaws.com/podinfo-demo/podinfo@${SELECTED_DIGEST}"
          
          echo "digest=${SELECTED_DIGEST}" >> $GITHUB_OUTPUT
          echo "image-uri=${FULL_URI}" >> $GITHUB_OUTPUT
          echo "environment=${TARGET_ENV}" >> $GITHUB_OUTPUT
          
          echo "Resolved Lambda artifact: ${FULL_URI} (Env: ${TARGET_ENV})"
      
      - name: Update Function Configuration
        run: |
          TARGET_FUNC="podinfo-demo-podinfo-${{ steps.image.outputs.environment }}"
          ARTIFACT_URI="${{ steps.image.outputs.image-uri }}"
          
          echo "Applying update to function: ${TARGET_FUNC}"
          
          aws lambda update-function-code \
            --function-name ${TARGET_FUNC} \
            --image-uri ${ARTIFACT_URI} \
            --publish
          
          echo "Polling for update completion..."
          aws lambda wait function-updated \
            --function-name ${TARGET_FUNC}
          
          echo "Function code update finished."
      
      - name: Retrieve Published Version
        id: version
        run: |
          TARGET_FUNC="podinfo-demo-podinfo-${{ steps.image.outputs.environment }}"
          
          LATEST_VER=$(aws lambda list-versions-by-function \
            --function-name ${TARGET_FUNC} \
            --query 'Versions[-1].Version' \
            --output text)
          
          echo "version=${LATEST_VER}" >> $GITHUB_OUTPUT
          echo "Detected new version: ${LATEST_VER}"
      
      - name: Shift Alias Traffic
        run: |
          TARGET_FUNC="podinfo-demo-podinfo-${{ steps.image.outputs.environment }}"
          NEW_VER="${{ steps.version.outputs.version }}"
          
          echo "Pointing 'live' alias to version ${NEW_VER}"
          
          aws lambda update-alias \
            --function-name ${TARGET_FUNC} \
            --name live \
            --function-version ${NEW_VER}
          
          echo "Alias traffic shift initiated."
      
      - name: Verify Lambda Health
        run: |
          ENDPOINT=$(aws apigatewayv2 get-apis \
            --query "Items[?Name=='podinfo-demo-${{ steps.image.outputs.environment }}'].ApiEndpoint" \
            --output text)
          
          echo "Checking health at: ${ENDPOINT}/healthz"
          
          for attempt in {1..10}; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" ${ENDPOINT}/healthz)
            if [ "$HTTP_CODE" == "200" ]; then
              echo "Health check succeeded on attempt $attempt"
              exit 0
            fi
            echo "Attempt $attempt failed. Retrying in 5s..."
            sleep 5
          done
          
          echo "Health check failed after multiple attempts."
          exit 1

  deploy-ec2:
    name: EC2 Target Deployment
    runs-on: ubuntu-latest
    needs: deploy-lambda
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Authenticate with AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Determine EC2 Artifact
        id: image
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            SELECTED_DIGEST="${{ github.event.inputs.image_digest_ec2 }}"
            TARGET_ENV="${{ github.event.inputs.environment }}"
          else
            SELECTED_DIGEST=$(aws ecr describe-images \
              --repository-name podinfo-demo/podinfo \
              --query "sort_by(imageDetails[?imageTags!=null], &imagePushedAt) | reverse(@)[?contains(imageTags[0], 'ec2')] | [0].imageDigest" \
              --output text)
            TARGET_ENV="dev"
          fi
          
          FULL_URI="553600746148.dkr.ecr.eu-central-1.amazonaws.com/podinfo-demo/podinfo@${SELECTED_DIGEST}"
          
          echo "digest=${SELECTED_DIGEST}" >> $GITHUB_OUTPUT
          echo "image-uri=${FULL_URI}" >> $GITHUB_OUTPUT
          echo "environment=${TARGET_ENV}" >> $GITHUB_OUTPUT
          
          echo "Resolved EC2 artifact: ${FULL_URI}"
      
      - name: Refresh Launch Template Configuration
        run: |
          set -e
          ARTIFACT_URI="${{ steps.image.outputs.image-uri }}"
          SHA_DIGEST="${{ steps.image.outputs.digest }}"
          TARGET_ENV="${{ steps.image.outputs.environment }}"
          
          echo "Environment: ${TARGET_ENV}"
          
          TEMPLATE_ID=$(aws ec2 describe-launch-templates \
            --filters "Name=tag:Name,Values=podinfo-demo-lt-${TARGET_ENV}" \
            --query 'LaunchTemplates[0].LaunchTemplateId' \
            --output text)
          
          echo "Modifying Template ID: ${TEMPLATE_ID}"
          
          OLD_USER_DATA=$(aws ec2 describe-launch-template-versions \
            --launch-template-id ${TEMPLATE_ID} \
            --versions '$Latest' \
            --query 'LaunchTemplateVersions[0].LaunchTemplateData.UserData' \
            --output text)
          
          RAW_DATA=$(echo "${OLD_USER_DATA}" | base64 -d)
          UPDATED_DATA=$(echo "$RAW_DATA" | sed -E "s|podinfo-demo/podinfo@sha256:[a-f0-9]{64}|podinfo-demo/podinfo@${SHA_DIGEST}|g")
          ENCODED_DATA=$(echo "$UPDATED_DATA" | base64 -w0)
          
          NEW_VER_NUM=$(aws ec2 create-launch-template-version \
            --launch-template-id ${TEMPLATE_ID} \
            --source-version '$Latest' \
            --launch-template-data "{\"UserData\":\"${ENCODED_DATA}\"}" \
            --query 'LaunchTemplateVersion.VersionNumber' \
            --output text)
          
          echo "Launch Template version ${NEW_VER_NUM} created."
          
          echo "Locating active Auto Scaling Group..."
          
          PRIMARY_ASG=$(aws autoscaling describe-auto-scaling-groups \
            --query "AutoScalingGroups[?AutoScalingGroupName=='podinfo-demo-asg-${TARGET_ENV}' && DesiredCapacity>\`0\`] | [0].AutoScalingGroupName" \
            --output text)
          
          if [ "$PRIMARY_ASG" != "None" ] && [ -n "$PRIMARY_ASG" ]; then
            CURRENT_ASG="$PRIMARY_ASG"
            echo "Identified Primary ASG: ${CURRENT_ASG}"
          else
            echo "Primary ASG inactive. Checking for CodeDeploy ASGs..."
            
            CD_CREATED_ASG=$(aws autoscaling describe-auto-scaling-groups \
              --query "AutoScalingGroups[?starts_with(AutoScalingGroupName, 'CodeDeploy_podinfo-demo-ec2-dg-${TARGET_ENV}_') && DesiredCapacity>\`0\`] | [0].AutoScalingGroupName" \
              --output text)
            
            if [ "$CD_CREATED_ASG" == "None" ] || [ -z "$CD_CREATED_ASG" ]; then
              echo "CRITICAL: No active ASG found for ${TARGET_ENV}."
              exit 1
            fi
            
            CURRENT_ASG="$CD_CREATED_ASG"
            echo "Identified CodeDeploy ASG: ${CURRENT_ASG}"
          fi
          
          echo "Applying new Launch Template to ASG: ${CURRENT_ASG}"
          
          aws autoscaling update-auto-scaling-group \
            --auto-scaling-group-name "${CURRENT_ASG}" \
            --launch-template "LaunchTemplateId=${TEMPLATE_ID},Version=\$Latest"
          
          echo "ASG updated. CodeDeploy will utilize this configuration for the Green fleet."
      
      - name: Build Deployment Bundle
        run: |
          TARGET_IMAGE="${{ steps.image.outputs.image-uri }}"
          echo "Preparing scripts for image: ${TARGET_IMAGE}"
          
          mkdir -p deployment/scripts
          
          cat > deployment/appspec.yml <<'EOF'
          version: 0.0
          os: linux
          hooks:
            ApplicationStop:
              - location: scripts/stop_container.sh
                timeout: 60
                runas: root
            BeforeInstall:
              - location: scripts/install_dependencies.sh
                timeout: 300
                runas: root
            ApplicationStart:
              - location: scripts/start_container.sh
                timeout: 300
                runas: root
            ValidateService:
              - location: scripts/validate_service.sh
                timeout: 300
                runas: root
          EOF
          
          cat > deployment/scripts/stop_container.sh <<'EOF'
          #!/bin/bash
          echo ">>> Stopping application container..."
          
          if docker ps -a | grep -q podinfo; then
             docker stop podinfo 2>/dev/null || true
             docker rm podinfo 2>/dev/null || true
             echo "Container stopped and removed."
          else
             echo "No active container found."
          fi
          
          # Force cleanup
          STUCK_ID=$(docker ps -aq -f name=podinfo)
          if [ -n "$STUCK_ID" ]; then
             docker rm -f $STUCK_ID 2>/dev/null || true
          fi
          
          exit 0
          EOF
          
          cat > deployment/scripts/install_dependencies.sh <<'EOF'
          #!/bin/bash
          echo "Dependencies verified via User Data."
          EOF
          
          cat > deployment/scripts/start_container.sh <<'EOF'
          #!/bin/bash
          set -e
          
          URI="__IMAGE_URI_PLACEHOLDER__"
          REGION="eu-central-1"
          
          echo ">>> Initializing container..."
          
          aws ecr get-login-password --region ${REGION} | \
            docker login --username AWS --password-stdin 553600746148.dkr.ecr.eu-central-1.amazonaws.com
          
          docker pull ${URI}
          
          echo "Retrieving secure configuration..."
          set +x 2>/dev/null || true
          
          RETRIEVED_SECRET=$(aws secretsmanager get-secret-value \
            --secret-id /dockyard/SUPER_SECRET_TOKEN \
            --region ${REGION} \
            --query SecretString \
            --output text 2>/dev/null)
          
          if [ -z "$RETRIEVED_SECRET" ]; then
            RETRIEVED_SECRET="placeholder-value"
          fi
          
          # Clean slate
          docker rm -f podinfo 2>/dev/null || true
          
          echo "Launching container..."
          docker run -d \
            --name podinfo \
            --restart unless-stopped \
            -p 9898:9898 \
            -e PORT=9898 \
            -e LOG_LEVEL=info \
            -e SUPER_SECRET_TOKEN="$RETRIEVED_SECRET" \
            ${URI} >/dev/null
          
          unset RETRIEVED_SECRET
          set -x 2>/dev/null || true
          
          sleep 3
          if docker ps | grep -q podinfo; then
            echo "Container is running."
          else
            echo "Container failed to start."
            exit 1
          fi
          EOF
          
          sed -i "s|__IMAGE_URI_PLACEHOLDER__|${TARGET_IMAGE}|g" deployment/scripts/start_container.sh
          
          cat > deployment/scripts/validate_service.sh <<'EOF'
          #!/bin/bash
          for i in {1..30}; do
            if curl -f http://localhost:9898/healthz; then
              echo "Local health check passed."
              exit 0
            fi
            sleep 2
          done
          echo "Local health check failed."
          exit 1
          EOF
          
          chmod +x deployment/scripts/*.sh
          tar -czf deployment.tar.gz -C deployment .
      
      - name: Upload Bundle to S3
        id: upload
        run: |
          TARGET_BUCKET="podinfo-demo-deployments-${{ steps.image.outputs.environment }}-553600746148"
          S3_KEY="deployments/podinfo-${{ github.run_number }}.tar.gz"
          
          aws s3 cp deployment.tar.gz s3://${TARGET_BUCKET}/${S3_KEY}
          
          echo "bucket=${TARGET_BUCKET}" >> $GITHUB_OUTPUT
          echo "key=${S3_KEY}" >> $GITHUB_OUTPUT
          echo "Artifact uploaded to ${TARGET_BUCKET}"
      
      - name: Halt Active Deployments
        run: |
          set +e
          CD_APP="podinfo-demo-ec2-${{ steps.image.outputs.environment }}"
          CD_GROUP="podinfo-demo-ec2-dg-${{ steps.image.outputs.environment }}"
          
          RUNNING_DEPLOYMENT=$(aws deploy list-deployments \
            --application-name ${CD_APP} \
            --deployment-group-name ${CD_GROUP} \
            --include-only-statuses "Created" "Queued" "InProgress" "Ready" \
            --query 'deployments[0]' \
            --output text 2>/dev/null)
          
          if [ "$RUNNING_DEPLOYMENT" != "None" ] && [ -n "$RUNNING_DEPLOYMENT" ]; then
            echo "Stopping previous deployment: $RUNNING_DEPLOYMENT"
            aws deploy stop-deployment \
              --deployment-id "$RUNNING_DEPLOYMENT" \
              --auto-rollback-enabled \
              2>/dev/null
            sleep 30
          else
            echo "No conflicting deployments found."
          fi
          set -e
      
      - name: Initiate Blue/Green Deployment
        id: deploy
        run: |
          CD_APP="podinfo-demo-ec2-${{ steps.image.outputs.environment }}"
          CD_GROUP="podinfo-demo-ec2-dg-${{ steps.image.outputs.environment }}"
          
          NEW_DEPLOYMENT_ID=$(aws deploy create-deployment \
            --application-name ${CD_APP} \
            --deployment-group-name ${CD_GROUP} \
            --s3-location bucket=${{ steps.upload.outputs.bucket }},key=${{ steps.upload.outputs.key }},bundleType=tgz \
            --description "Automated deploy of ${{ steps.image.outputs.digest }}" \
            --query 'deploymentId' \
            --output text)
          
          echo "deployment-id=${NEW_DEPLOYMENT_ID}" >> $GITHUB_OUTPUT
          echo "Deployment initiated: ${NEW_DEPLOYMENT_ID}"
      
      - name: Monitor Deployment Progress
        run: |
          DEPLOY_ID="${{ steps.deploy.outputs.deployment-id }}"
          echo "Tracking deployment ${DEPLOY_ID}..."
          aws deploy wait deployment-successful --deployment-id ${DEPLOY_ID}
          echo "Deployment successful."
      
      - name: Validate ALB Endpoint
        run: |
          LB_DNS=$(aws elbv2 describe-load-balancers \
            --names "podinfo-demo-alb-${{ steps.image.outputs.environment }}" \
            --query 'LoadBalancers[0].DNSName' \
            --output text)
          
          echo "Probing ALB: https://${LB_DNS}/healthz"
          
          for attempt in {1..10}; do
            HTTP_STATUS=$(curl -k -s -o /dev/null -w "%{http_code}" https://${LB_DNS}/healthz)
            if [ "$HTTP_STATUS" == "200" ]; then
              echo "Endpoint verified on attempt $attempt"
              exit 0
            fi
            echo "Probe $attempt failed. Retrying..."
            sleep 5
          done
          
          echo "ALB validation failed."
          exit 1
      
      - name: Prune Stale Auto Scaling Groups
        if: success()
        run: |
          TARGET_ENV="${{ steps.image.outputs.environment }}"
          
          echo "Pausing for 120s to allow rotation finalization..."
          sleep 120
          
          TERMINATED_ASGS=$(aws autoscaling describe-auto-scaling-groups \
            --query "AutoScalingGroups[?starts_with(AutoScalingGroupName, 'CodeDeploy_podinfo-demo-ec2-dg-${TARGET_ENV}_') && DesiredCapacity==\`0\`].AutoScalingGroupName" \
            --output text)
          
          if [ -z "$TERMINATED_ASGS" ]; then
            echo "No stale ASGs detected."
            exit 0
          fi
          
          for group in $TERMINATED_ASGS; do
            echo "Removing: $group"
            aws autoscaling delete-auto-scaling-group \
              --auto-scaling-group-name "$group" \
              --force-delete \
              2>/dev/null || echo "Could not delete $group (might be already gone)."
          done
  
  summary:
    name: Pipeline Report
    runs-on: ubuntu-latest
    needs: [deploy-lambda, deploy-ec2]
    if: always()
    
    steps:
      - name: Write Summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # Deployment Status Report
          
          | Stage | Result |
          |-------|--------|
          | **Overall** | ${{ needs.deploy-lambda.result == 'success' && needs.deploy-ec2.result == 'success' && 'PASS' || 'FAIL' }} |
          | **Lambda** | \`${{ needs.deploy-lambda.result }}\` |
          | **EC2** | \`${{ needs.deploy-ec2.result }}\` |
          
          **Context:**
          - Commit: \`${{ github.sha }}\`
          - Run ID: #${{ github.run_number }}
          EOF